package data.scripts.shipsystems;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.lazywizard.lazylib.FastTrig;
import org.lazywizard.lazylib.MathUtils;
import org.lwjgl.util.vector.Vector2f;

import com.fs.starfarer.api.Global;
import com.fs.starfarer.api.combat.CombatEngineAPI;
import com.fs.starfarer.api.combat.DamagingProjectileAPI;
import com.fs.starfarer.api.combat.MutableShipStatsAPI;
import com.fs.starfarer.api.combat.OnFireEffectPlugin;
import com.fs.starfarer.api.combat.ShipAPI;
import com.fs.starfarer.api.combat.WeaponAPI;
import com.fs.starfarer.api.combat.WeaponAPI.WeaponType;
import com.fs.starfarer.api.impl.combat.BaseShipSystemScript;
import com.fs.starfarer.api.loading.ProjectileSpecAPI;
import com.fs.starfarer.api.util.Misc;

public class espc_SlamfireStats extends BaseShipSystemScript {
	
	private static final float OVERLOAD_DUR = 2.0f;
	// velocity ship is knocked back by using this ability.  currently not dependent on ship mass - even upscaled, we can assume
	// the firepower a ship produces from this ability scales roughly with its mass.
	private static final float KNOCKBACK = 700.0f * 200f;
	// floor for flux generated by each shot, primarily for performance reasons.
	private static final float MIN_FLUX_COST = 20f;
	private static final float MAX_DAMAGE_MULT = 3f;
	
	private static final float CANCEL_COOLDOWN_FRACTION = 0.15f;
	
	// state machine
	private int burstState = 0;

	private class SlamWeapon {
		public WeaponAPI weapon;
		public OnFireEffectPlugin weaponEffectPlugin = null;
		public OnFireEffectPlugin projEffectPlugin = null;
		public float projectileCountMult = 1f;
		public float damageMult = 1f;
		public float rateOfFire;
		public float fluxPerSecond;
		public int burstSize;
		public int numBarrels;
		public int linkedMult;
		public boolean isHardpoint = false;
		public float fluxPortion = 0f;
		
		public SlamWeapon(WeaponAPI weapon, ShipAPI ship) {
			this.weapon = weapon;
			rateOfFire = 1f / weapon.getDerivedStats().getRoF();
			isHardpoint = weapon.getSlot().isHardpoint();
			numBarrels = isHardpoint ? weapon.getSpec().getHardpointAngleOffsets().size() :
				weapon.getSpec().getTurretAngleOffsets().size();
			
			burstSize = weapon.getSpec().getBurstSize();
			if (burstSize > 100)
				burstSize = 1;
			
			linkedMult = (int) (weapon.getDerivedStats().getDamagePerShot() /
				((ProjectileSpecAPI) weapon.getSpec().getProjectileSpec()).getDamage().getBaseDamage());
			
			if (weapon.getFluxCostToFire() < MIN_FLUX_COST) {
				projectileCountMult = weapon.getFluxCostToFire() / MIN_FLUX_COST;
				damageMult = Math.min(MIN_FLUX_COST / weapon.getFluxCostToFire(), 
					MAX_DAMAGE_MULT);
			}
			
			if (weapon.getEffectPlugin() != null) {
				if (weapon.getEffectPlugin().getClass().isAssignableFrom(OnFireEffectPlugin.class))
					weaponEffectPlugin = (OnFireEffectPlugin) weapon.getEffectPlugin();
			}
				
			if (weapon.getSpec().getProjectileSpec() != null) {
				if (((ProjectileSpecAPI) weapon.getSpec().getProjectileSpec()).getOnFireEffect() != null)
					projEffectPlugin = ((ProjectileSpecAPI) weapon.getSpec().getProjectileSpec()).getOnFireEffect();
			}
			fluxPerSecond = weapon.getDerivedStats().getFluxPerSecond();
		}
	}
	
    @Override
    public void apply(MutableShipStatsAPI stats, String id, State state, float effectLevel)
    {
        if (stats.getEntity() == null)
            return;
		
		ShipAPI ship = (ShipAPI) stats.getEntity();
		
		// stats.getBallisticWeaponFluxCostMod().modifyMult(id, 1f - FLUX_REDUCTION * effectLevel);
		
		// check for when the weapon fires.
		if (burstState <= 1) {
			if (burstState == 0) {
				if (ship.getSelectedGroupAPI() != null)
					burstState = 1;
				else {
					burstState = 3;
					return;
				}
			}
			for (WeaponAPI weapon : ship.getSelectedGroupAPI().getWeaponsCopy()) {
				if (weapon.getType() != WeaponType.BALLISTIC || weapon.isBeam() || weapon.getFluxCostToFire() <= 0f)
					continue;
				if (weapon.isFiring() && weapon.getCooldownRemaining() <= 0f) {
					if (burstState == 1) {
						burstState = 2;
						break;
					}
				}
			}
		}
		
		// as there's no way to manually force fire a weapon
		// (AT THE TIME OF WRITING.  alex added the method
		// but it probably can't shit out a billion projs like you can here.  can it?  end my misery.)
		// we'll have to duplicate its projectiles to simulate the equivalent instead.
		// to modders: sorry lol.
		if (burstState == 2) {
			CombatEngineAPI combatEngine = Global.getCombatEngine();
			ArrayList<SlamWeapon> firingWeapons = new ArrayList<SlamWeapon>();
			LinkedList<WeaponAPI> weapons = new LinkedList<WeaponAPI>();
			float groupFluxCost = 0f;
			for (WeaponAPI weapon : ship.getSelectedGroupAPI().getWeaponsCopy()) {
				if (weapon.getType() == WeaponType.BALLISTIC &&
					!weapon.isBeam() && weapon.getFluxCostToFire() > 0f) {
					SlamWeapon addWep = new SlamWeapon(weapon, ship);
					weapons.addLast(weapon);
					groupFluxCost += addWep.fluxPerSecond;
					for (int i = 0; i < firingWeapons.size() + 1; i++) {
						if (i == firingWeapons.size() ||
							weapon.getFluxCostToFire() > 
							((SlamWeapon) firingWeapons.get(i)).weapon.getFluxCostToFire()) {
							firingWeapons.add(i, addWep);
							break;
						}
					}
					if (weapon.getAnimation() != null) {
						weapon.getAnimation().reset();
						weapon.getAnimation().play();
					}
				}
			}

			float fluxDiff = ship.getFluxLevel();
			float remainingFlux = ship.getMaxFlux() - ship.getCurrFlux();
			// the amount of flux spent proportional to the knockback you should get from firing.
			Vector2f newVel = new Vector2f();
			/*
			newVel = 
				Vector2f.add(
					new Vector2f(
						(float) FastTrig.cos(Math.toRadians(ship.getFacing())) * (1f - fluxDiff) * -KNOCKBACK / ship.getMass(), 
						(float) FastTrig.sin(Math.toRadians(ship.getFacing())) * (1f - fluxDiff) * -KNOCKBACK / ship.getMass()
					), ship.getVelocity(), new Vector2f()
				);
			*/
			espc_SlamfireVFX plugin = new espc_SlamfireVFX(
				ship, new Vector2f(ship.getVelocity().x, ship.getVelocity().y), weapons
			);
			Global.getCombatEngine().addPlugin(plugin);	
			
			// while (remainingFlux > 0f) {
			Iterator<SlamWeapon> firingIterator = firingWeapons.iterator();
			while (firingIterator.hasNext()) {
				SlamWeapon currWeapon = (SlamWeapon) firingIterator.next();
				List<Float> angleOffsets = currWeapon.isHardpoint ?
					currWeapon.weapon.getSpec().getHardpointAngleOffsets() :
					currWeapon.weapon.getSpec().getTurretAngleOffsets();
				for (int i = 0;
					i < (int) Math.floor(remainingFlux/groupFluxCost / currWeapon.rateOfFire * currWeapon.projectileCountMult)
					* currWeapon.linkedMult;
					i++
					) {
					// range and speed variation biased as a bonus.  helps compensate for the ai being a little haphazard with use.
					stats.getBallisticProjectileSpeedMult().modifyMult(id, Misc.random.nextFloat() * 0.15f + 0.95f);
					stats.getBallisticWeaponRangeBonus().modifyMult(id, Misc.random.nextFloat()* 0.25f + 1.0f);
					stats.getBallisticWeaponDamageMult().modifyMult(id, currWeapon.damageMult);
					DamagingProjectileAPI cloneProj = (DamagingProjectileAPI) combatEngine.spawnProjectile(
						ship,
						currWeapon.weapon,
						currWeapon.weapon.getId(),
						// currWeapon.getSpec().getProjectileSpec().getId(),
						currWeapon.weapon.getFirePoint(i % currWeapon.numBarrels),
						//new Vector2f(proj.getLocation().x + (Misc.random.nextFloat() * 10f - 5f), proj.getLocation().y + (Misc.random.nextFloat() * 10f - 3f)),
						// 2x regular max weapon spread, plus some more on top.
						currWeapon.weapon.getCurrAngle() +
							((Float) angleOffsets.get(i % currWeapon.numBarrels)) +
							(Misc.random.nextFloat() * 1f - 0.5f) *
							(currWeapon.weapon.getSpec().getMaxSpread() + 3f) *
							(currWeapon.isHardpoint ? 1f : 2f),
						ship.getVelocity()
					);
					stats.getBallisticProjectileSpeedMult().unmodify(id);
					stats.getBallisticWeaponRangeBonus().unmodify(id);
					stats.getBallisticWeaponDamageMult().unmodify(id);
					
					if (i < 8)
						plugin.addProj(cloneProj);
					
					if (currWeapon.weaponEffectPlugin != null)
						currWeapon.weaponEffectPlugin.onFire(cloneProj, currWeapon.weapon, combatEngine);
					if (currWeapon.projEffectPlugin != null && cloneProj != null)
						currWeapon.projEffectPlugin.onFire(cloneProj, currWeapon.weapon, combatEngine);
				}
					
				if (currWeapon.weapon.getFluxCostToFire() > 0f)
					currWeapon.weapon.setAmmo(Math.max(currWeapon.weapon.getAmmo() - 
						(int) Math.floor(remainingFlux/groupFluxCost / currWeapon.rateOfFire)
					, 0)
				);
				// Global.getLogger(espc_SlamfireStats.class).info("fluxPortion: " + 
				// 	(float) Math.floor(remainingFlux/groupFluxCost / currWeapon.rateOfFire)
				// 	* currWeapon.weapon.getFluxCostToFire() / currWeapon.burstSize);
				currWeapon.fluxPortion = (float) Math.floor(remainingFlux/groupFluxCost / currWeapon.rateOfFire)
					* currWeapon.weapon.getFluxCostToFire() / currWeapon.burstSize / ship.getMaxFlux();
				
				Vector2f.add(
					newVel, 
					new Vector2f(
						(float) FastTrig.cos(Math.toRadians(currWeapon.weapon.getCurrAngle())) * currWeapon.fluxPortion,
						(float) FastTrig.sin(Math.toRadians(currWeapon.weapon.getCurrAngle())) * currWeapon.fluxPortion
					),
					newVel
				);
				
				for (int i = 0; i < currWeapon.numBarrels; i++) {
					combatEngine.addHitParticle(
						currWeapon.weapon.getFirePoint(i),
						ship.getVelocity(),
						50 + 100 * currWeapon.fluxPortion / currWeapon.numBarrels,
						0.6f,
						0.3f,
						new Color(255, 125, 0, 40)
					);
					combatEngine.addHitParticle(
						currWeapon.weapon.getFirePoint(i),
						ship.getVelocity(),
						15 + 35 * currWeapon.fluxPortion / currWeapon.numBarrels,
						2f,
						0.15f,
						new Color(255, 235, 200, 255)
					);
					for (int g = 0; g < currWeapon.fluxPortion * 20 / currWeapon.numBarrels; g++) {
						combatEngine.addHitParticle(
							MathUtils.getRandomPointInCone(
								currWeapon.weapon.getFirePoint(i),
								(45f + 25f * currWeapon.fluxPortion) 
									/ (currWeapon.fluxPortion * 20f / currWeapon.numBarrels) * g,
								currWeapon.weapon.getCurrAngle() + ((Float) angleOffsets.get(i))
									- 6f - 10f * currWeapon.fluxPortion,
								currWeapon.weapon.getCurrAngle() + ((Float) angleOffsets.get(i))
									+ 6f + 10f * currWeapon.fluxPortion
							),
							ship.getVelocity(),
							Misc.random.nextFloat() * 35f + g * 1f,
							1,
							0.4f,
							new Color(225, (int) (Misc.random.nextFloat() * 80) + 20, 20, 125)
						);
					}
				}
				
				remainingFlux -= Math.floor(remainingFlux/groupFluxCost / currWeapon.rateOfFire)
					* currWeapon.weapon.getFluxCostToFire() / currWeapon.burstSize;
				groupFluxCost -= currWeapon.fluxPerSecond;
			}
			
			Global.getSoundPlayer().playSound("mjolnir_fire", 1f, 0.7f, ship.getLocation(), ship.getVelocity());
			Global.getSoundPlayer().playSound("mine_explosion", 1.0f, 1.0f, ship.getLocation(), ship.getVelocity());

			stats.getBallisticProjectileSpeedMult().unmodify(id);
			stats.getBallisticWeaponRangeBonus().unmodify(id);
			stats.getBallisticWeaponDamageMult().unmodify(id);
			
			newVel.scale((1f - fluxDiff) * -KNOCKBACK / ship.getMass());
			Vector2f.add(ship.getVelocity(), newVel, ship.getVelocity());
			
			// unsure how exactly this is calculated vanilla
			// but to make this system more viable it helps to make the overload generously short-lived.
			burstState = 3;
			ship.getFluxTracker().setCurrFlux(ship.getMaxFlux());
			ship.getFluxTracker().setOverloadDuration(OVERLOAD_DUR);
			ship.getFluxTracker().setOverloadProgress(0.0f);
			/*
			for (WeaponAPI weapon : ship.getAllWeapons()) {
				if (weapon.getType() == WeaponType.BALLISTIC && weapon.usesAmmo()) {
					weapon.setAmmo(0);
					weapon.setRefireDelay(0f);
					weapon.setRemainingCooldownTo(0f);
				}
			}*/
		} else if (state == State.OUT && burstState != 4 && !ship.getFluxTracker().isOverloaded()) {
			burstState = 4;
			Global.getSoundPlayer().playSound(
				"system_fast_missile_racks", 0.85f, 1f, ship.getLocation(), ship.getVelocity());
		}
		
    }

    @Override
    public void unapply(MutableShipStatsAPI stats, String id)
    {
    	// if we cancel the system rather than actually using it, shorten the cooldown.
    	if (burstState == 4 || burstState < 2) {
    		ShipAPI ship = (ShipAPI) stats.getEntity();
    		ship.getSystem().setCooldownRemaining(ship.getSystem().getCooldown() * CANCEL_COOLDOWN_FRACTION);
    	}
		burstState = 0;
		// stats.getBallisticRoFMult().unmodify(id);
		// stats.getBallisticWeaponFluxCostMod().unmodify(id);
    }
	

	
	public StatusData getStatusData(int index, State state, float effectLevel) {
		if (index == 0) {
			return new StatusData("will consume all flux on next ballistic shot", false);
		}
		return null;
	}
	
}